\section{The policy process model}
\label{sec:documentationPolicy}

The following is the documentation for the policy process model.

%%%%%%%%%%%%
\subsection{model\_SM.py}

The \texttt{model\_SM.py} is the main file fo the policy emergence model. This is where the policy process is coded and stepped through. The different functions of this files are outlined below:

\begin{itemize}
\item \texttt{get\_agents\_attributes()}

This function is used as part of the datacollector function. This function is used to output the key attributed of the policy emergence model agents. Note that a deepcopy function is used for to avoid data rewriting over itself.

\item \texttt{get\_electorate\_attributes()}

This function is similar to the previous one but for the electorate attributes.

\item \texttt{get\_problem\_policy\_chosen()}

This function is also used as part of the datacollector function. This function records the agenda selected and the policy implemented by the agents.

\item \texttt{step()}

The step function is the main core of policy emergence model. It consists of a set of steps. These are the initialisation, the agenda setting, the policy formulation and the data collection. For the initialisation, this includes the communication of the beliefs from the environment and the impact of the policy instruments to the agents.

\item \texttt{module\_interface\_input()}

The module interface function is used to inform the active agents of what has happened in the environment. This includes taking the indicators and feeding them to the truth agent. Taking the truth agents issue tree and informing all active agents. Finally, it includes informing the active agents about the policy instruments' impact that are recalculated for every step of the policy emergence model.

\item \texttt{agenda\_setting()}

In the agenda setting step, the active agents first select their policy core issue of preference and then select the agenda. Then we check for all preferences for all agents and see whether there is a majority of one policy core issue. If that is the case, then the policy formulation can happen.
		
\item \texttt{policy\_formulation()}

In the policy formulation step, the policy maker agents first select their policy core issue of preference and then they select the policy that is to be implemented if there is a majority of them.

\item \texttt{preference\_update()}

This function is used to call the preference update functions of the issues of the active agents.

\item \texttt{preference\_update\_DC()}

This function is used to update the preferences of the deep core issues of agents in their respective issue trees.

\item \texttt{preference\_update\_PC()}

This function is used to update the preferences of the policy core issues of agents in their respective issue trees.
		
\item \texttt{preference\_update\_S()}

This function is used to update the preferences of secondary issues the agents in their respective issue trees.

\item \texttt{electorate\_influence()}

This function calls the influence actions in the electorate agent class.

\end{itemize}

%%%%%%%%%%%% end of model\_SM.py

%%%%%%%%%%%%
\subsection{model\_SM\_agents.py}

\begin{itemize}
\item \texttt{ActiveAgent} class:

The active agent class contains the policy makers and the policy entrepreneurs. These are agents that have a say in the agenda setting and the policy formulation.

	\begin{itemize}
	\item \texttt{selection\_PC()}
	
	This function is used to select the preferred policy core issue for the active agents based on all their preferences for the policy core issues.
	
	\item \texttt{selection\_S()}
	
	This function is used to select the preferred secondary issue. First, only the secondary issues that are related, through a causal relation, to the policy core issue on the agenda are placed into an array. Then, the one with the highest preference is selected. It is then used as the issue that the agent will advocate for later on.
	\item \texttt{selection\_PI()}
	
	This function is used to select the preferred policy instrument from the policy family on the agenda. First the preferences are calculated. Then the policy family preferred is selected as the policy family with the lowest preference (this means the smallest gap after the introduction of the policy family likelihood).

	\end{itemize}

\item \texttt{ElectorateAgent} class:

This is the electorate agent class. These agents are only used to influence the policy makers. They cannot be influenced by agents within the system.

	\begin{itemize}
	\item \texttt{electorate\_influence()}
	
	This function is used to perform the electorate influence on the policy makers.
	\end{itemize}
	
\item \texttt{TruthAgent} class:

This is the truth agent class. It is used to transfer the indicators into beliefs for the active agents.

\end{itemize}

%%%%%%%%%%%% end of model\_SM\_agents.py


%%%%%%%%%%%%
\subsection{model\_SM\_agents\_initialisation.py}

\begin{itemize}
\item \texttt{issuetree\_creation()}

This function is used to create a skeleton issue tree. This stores all of the issues of the agents.

\item \texttt{policytree\_creation()}

This function is used to create a skeleton policy tree. This stores all of the policy instruments of the agents.

\item \texttt{init\_active\_agents()}

This function creates all of the active agents that are specified within the inputs of the model.

\item \texttt{init\_electorate\_agents()}

This function creates the electorate passive agents. The electorate 

\item \texttt{init\_truth\_agent()}

This function is used to create the truth agent. It has a limited set of attributes and a different structure for its policy tree (it does not need any causal relations).

\end{itemize}


%%%%%%%%%%%% end of model\_SM\_agents\_initialisation.py

%%%%%%%%%%%%
\subsection{model\_SM\_policyImpact.py}

This script is used to calculate the impact of the policy instruments. It is done by simulating a separate instance of the model with a specific policy instrument and by recording the outcome. Such simulation are done using parallel processes. Two functions are considered within this script:

\begin{itemize}
\item \texttt{model\_simulation()}

This function is used to run the independent simulations of the model. It takes in the inputs from the model and outputs the indicators as a result from the simulation.

\item \texttt{policy\_impact\_evaluation()}

This function is used to estimate the impact of the policy instruments on the policy context. This is done by separately simulating every policy instruments and comparing the results with the initial states of the policy context. This is what is then used to inform the agents on the impact of the policies.

\end{itemize}


%%%%%%%%%%%% end of model\_SM\_policyImpact.py

